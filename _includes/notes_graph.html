{%- assign tagged_docs = site.notes | where_exp: "n", "n.tags != nil" -%}
{%- assign graph_id = include.graph_id | default: page.url | append: include.title | slugify -%}
{%- assign max_tag_nodes = include.max_tags | default: 0 -%}
{%- assign tag_graph = tagged_docs | build_note_tag_graph: max_tag_nodes -%}
{%- assign tag_nodes = tag_graph["tag_nodes"] | default: [] -%}
{%- assign note_nodes = tag_graph["note_nodes"] | default: [] -%}
{%- assign tag_edges = tag_graph["tag_edges"] | default: [] -%}
{%- assign note_edges = tag_graph["note_edges"] | default: [] -%}
{%- assign tag_graph_nodes = tag_nodes | concat: note_nodes -%}
{%- assign tag_graph_edges = tag_edges | concat: note_edges -%}
{%- assign tag_graph_nodes_json = tag_graph_nodes | jsonify -%}
{%- assign tag_graph_edges_json = tag_graph_edges | jsonify -%}

<div class="graph-layout graph-layout--split">
  <div class="graph-card graph-card--square graph-card--graph">
    <div class="graph-card__header">
      <div class="graph-title">{{ include.title | default: 'Notes Graph' }}</div>
    </div>
    <div class="graph-card__body">
      <div id="graph-wrapper-{{ graph_id }}" class="graph-canvas-wrap" data-graph-height="{{ include.height_factor | default: '0.75' }}">
        <canvas id="graph-canvas-{{ graph_id }}" class="graph-canvas" aria-label="Notes graph"></canvas>
      </div>
    </div>
  </div>
  <div class="graph-card graph-card--square graph-card--tags">
    <div class="graph-card__header">
      <div class="graph-title">Tags</div>
    </div>
    <div class="graph-card__body">
      <div id="tag-graph-wrapper-{{ graph_id }}" class="graph-canvas-wrap" data-graph-height="{{ include.height_factor | default: '0.75' }}">
        <canvas id="tag-graph-canvas-{{ graph_id }}" class="graph-canvas" aria-label="Tag graph"></canvas>
      </div>
    </div>
  </div>
</div>

<script>
  (function () {
    const graphId = "{{ graph_id }}";
    const wrapper = document.getElementById("graph-wrapper-" + graphId);
    const canvas = document.getElementById("graph-canvas-" + graphId);
    const tagWrapper = document.getElementById("tag-graph-wrapper-" + graphId);
    const tagCanvas = document.getElementById("tag-graph-canvas-" + graphId);
    if (!wrapper || !canvas || !tagWrapper || !tagCanvas) return;

    if (wrapper.dataset.graphInit === "true") return;
    wrapper.dataset.graphInit = "true";

    const data = {% include notes_graph.json %};
    const tagGraphData = { nodes: {{ tag_graph_nodes_json }}, edges: {{ tag_graph_edges_json }} };

    const readCssVar = (name, fallback) => {
      const root = getComputedStyle(document.documentElement);
      const val = root.getPropertyValue(name).trim();
      return val || fallback;
    };

    const colours = {
      page: readCssVar("--graph-page", "#f9c74f"),
      games: readCssVar("--graph-games", "#846a6a"),
      notes: readCssVar("--graph-notes", "#a2999e"),
      rockhounding: readCssVar("--graph-rockhounding", "#353b3c"),
      blog: {
        spring: readCssVar("--graph-blog-spring", "#e6a0b4"),
        summer: readCssVar("--graph-blog-summer", "#6fa36f"),
        fall: readCssVar("--graph-blog-fall", "#d28b2a"),
        winter: readCssVar("--graph-blog-winter", "#4f6d7a"),
      },
      rock: {
        igneous: readCssVar("--graph-igneous", "#f94144"),
        sedimentary: readCssVar("--graph-sedimentary", "#f9c74f"),
        metamorphic: readCssVar("--graph-metamorphic", "#577590"),
      },
      link: readCssVar("--graph-link", "rgba(53, 59, 60, 0.35)"),
      text: readCssVar("--graph-text", "#353b3c"),
      textMuted: readCssVar("--graph-text-muted", "rgba(53, 59, 60, 0.6)"),
      highlight: readCssVar("--graph-highlight", "#ffffff"),
      labelBg: readCssVar("--graph-label-bg", "rgba(8, 9, 14, 0.72)"),
      labelBorder: readCssVar("--graph-label-border", "rgba(255, 255, 255, 0.14)"),
    };

    const hexToRgb = (hex) => {
      if (!hex) return null;
      const normalized = hex.trim().replace("#", "");
      const chunk = normalized.length === 3
        ? normalized.split("").map((c) => c + c).join("")
        : normalized;
      if (chunk.length !== 6) return null;
      const intVal = parseInt(chunk, 16);
      if (Number.isNaN(intVal)) return null;
      return {
        r: (intVal >> 16) & 255,
        g: (intVal >> 8) & 255,
        b: intVal & 255,
      };
    };

    const tintedPalette = (hex, opacity = 0.16) => {
      const rgb = hexToRgb(hex);
      if (!rgb) {
        return {
          fill: "rgba(0, 0, 0, 0.05)",
          stroke: colours.link,
          text: colours.text,
        };
      }
      return {
        fill: `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`,
        stroke: `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.55)`,
        text: `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.9)`,
      };
    };

    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

    const seasonForDate = (dateStr) => {
      if (!dateStr) return null;
      const m = dateStr.toString().trim().match(/(\\d{4})-(\\d{2})-(\\d{2})/);
      if (!m) return null;
      const month = parseInt(m[2], 10);
      if (month >= 3 && month <= 5) return "spring";
      if (month >= 6 && month <= 8) return "summer";
      if (month >= 9 && month <= 11) return "fall";
      return "winter";
    };

    const colorForNode = (node) => {
      if (node.rock_class && colours.rock[node.rock_class]) {
        return colours.rock[node.rock_class];
      }
      if (node.layout === "page") return colours.page;
      if (node.category === "blog") {
        const season = seasonForDate(node.date);
        return colours.blog[season || "winter"];
      }
      return colours[node.category] || colours.notes;
    };

    const normalizePath = (path) => {
      if (!path) return "";
      const trimmed = path.trim();
      if (trimmed === "/") return "/";
      return trimmed.endsWith("/") ? trimmed : trimmed + "/";
    };

    const emphasizedCategories = new Set(["autism", "games", "rockhound", "rockhounding", "blog"]);

    const isCategoryNode = (node) => {
      if (!node) return false;
      const category = (node.category || "").toLowerCase();
      const label = (node.label || "").toLowerCase();
      const normalizedPath = normalizePath(node.path || "").toLowerCase();

      if (emphasizedCategories.has(category) || emphasizedCategories.has(label)) return true;

      return Array.from(emphasizedCategories).some((root) => {
        if (!root) return false;
        const rootPath = `/${root}/`;
        return (
          normalizedPath === rootPath ||
          normalizedPath.startsWith(`/notes/${root}/`) ||
          normalizedPath.startsWith(rootPath)
        );
      });
    };

    const isCurrentPath = (notePath) => {
      const current = normalizePath(window.location.pathname);
      const target = normalizePath(notePath);
      return current === target;
    };

    const buildGraph = (graphWrapper, graphCanvas, graphData, options) => {
      const ctx = graphCanvas.getContext("2d");
      const nodes = graphData.nodes.map((n) => ({ ...n }));
      const links = graphData.edges.map((e) => ({ source: e.source, target: e.target }));
      const byId = new Map(nodes.map((n) => [n.id, n]));
      const degree = {};
      links.forEach((l) => {
        degree[l.source] = (degree[l.source] || 0) + 1;
        degree[l.target] = (degree[l.target] || 0) + 1;
      });
      nodes.forEach((n) => {
        n.degree = degree[n.id] || 0;
      });
      const heightFactor = parseFloat(graphWrapper.dataset.graphHeight || "0.75");
      const safeHeightFactor = isNaN(heightFactor) ? 0.75 : heightFactor;
      let hoverNode = null;
      let focusNode = null;
      let isDragging = false;
      let didDrag = false;
      let dragClickGuard = false;
      let lastDrag = null;
      let isAnimating = false;
      let animStart = 0;
      let animFrom = null;
      let animTo = null;
      const camera = {
        scale: options.defaultScale,
        x: 0,
        y: 0,
      };
      const isSphereLayout = options.layout === "sphere";
      const sphereState = {
        radius: 0,
        angleX: -0.18,
        angleY: 0.24,
        velocityX: 0.0009,
        velocityY: -0.00078,
        targetVX: 0.0009,
        targetVY: -0.00078,
        wobbleAmp: 0.00018,
        hovering: false,
        spinHandle: null,
      };

      const labelForNode = (node) => {
        const label = node.label || "";
        if (!label) return "";
        const max = options.labelMax || 32;
        return label.length > max ? `${label.slice(0, max - 3)}...` : label;
      };

      const measureNodes = () => {
        ctx.save();
        ctx.font = options.font;
        nodes.forEach((n) => {
          const label = labelForNode(n);
          const metrics = ctx.measureText(label);
          const ascent = metrics.actualBoundingBoxAscent || 10;
          const descent = metrics.actualBoundingBoxDescent || 3;
          const textHeight = ascent + descent;
          const paddingX = options.chipPaddingX || 10;
          const paddingY = options.chipPaddingY || 6;
          n.__label = label;
          n.__chipWidth = metrics.width + paddingX * 2;
          n.__chipHeight = textHeight + paddingY * 2;
          n.__chipRadius = Math.max(10, n.__chipHeight / 2 + 6);
        });
        ctx.restore();
      };

      measureNodes();

      const initLayout = () => {
        if (isSphereLayout) return;
        const width = graphCanvas.width / window.devicePixelRatio;
        const height = graphCanvas.height / window.devicePixelRatio;
        nodes.forEach((n) => {
          n.x = Math.random() * width;
          n.y = Math.random() * height;
          n.vx = 0;
          n.vy = 0;
          n.mass = 1;
        });
      };

      const resolveId = (value) => {
        if (!value) return value;
        return typeof value === "string" ? value : value.id;
      };

      const layoutRadial = () => {
        const width = graphCanvas.width / window.devicePixelRatio;
        const height = graphCanvas.height / window.devicePixelRatio;
        const centerX = width / 2;
        const centerY = height / 2;
        const radiusStep = Math.max(40, Math.min(width, height) * 0.12);

        const adjacency = new Map();
        nodes.forEach((n) => adjacency.set(n.id, new Set()));
        links.forEach((l) => {
          const s = resolveId(l.source);
          const t = resolveId(l.target);
          if (!s || !t) return;
          if (!adjacency.has(s)) adjacency.set(s, new Set());
          if (!adjacency.has(t)) adjacency.set(t, new Set());
          adjacency.get(s).add(t);
          adjacency.get(t).add(s);
        });

        let centerId = focusNode ? focusNode.id : null;
        if (!centerId && options.centerOnCurrent) {
          const current = nodes.find((n) => isCurrentPath(n.path));
          if (current) centerId = current.id;
        }
        if (!centerId) {
          centerId = nodes.reduce((best, n) => (n.degree > best.degree ? n : best), nodes[0]).id;
        }

        const depth = new Map();
        const queue = [];
        depth.set(centerId, 0);
        queue.push(centerId);
        while (queue.length) {
          const id = queue.shift();
          const nextDepth = depth.get(id) + 1;
          (adjacency.get(id) || []).forEach((neighbor) => {
            if (!depth.has(neighbor)) {
              depth.set(neighbor, nextDepth);
              queue.push(neighbor);
            }
          });
        }

        const maxDepth = Math.max(0, ...Array.from(depth.values()));
        nodes.forEach((n) => {
          if (!depth.has(n.id)) depth.set(n.id, maxDepth + 1);
        });

        const ringMap = new Map();
        nodes.forEach((n) => {
          const d = depth.get(n.id) || 0;
          if (!ringMap.has(d)) ringMap.set(d, []);
          ringMap.get(d).push(n);
        });

        ringMap.forEach((ringNodes, d) => {
          if (d === 0) {
            ringNodes.forEach((n) => {
              n.x = centerX;
              n.y = centerY;
            });
            return;
          }
          const radius = d * radiusStep;
          const count = ringNodes.length;
          const offset = d * 0.35;
          ringNodes.forEach((n, i) => {
            const angle = (Math.PI * 2 * i) / count + offset;
            n.x = centerX + Math.cos(angle) * radius;
            n.y = centerY + Math.sin(angle) * radius;
          });
        });
      };

      const layoutSphere = () => {
        const width = graphCanvas.width / window.devicePixelRatio;
        const height = graphCanvas.height / window.devicePixelRatio;
        const minDim = Math.min(width, height);
        sphereState.radius = minDim * (options.sphereRadiusFactor || 0.38);
        const goldenAngle = Math.PI * (3 - Math.sqrt(5));

        nodes.forEach((n, i) => {
          const t = (i + 0.5) / Math.max(1, nodes.length);
          const phi = Math.acos(1 - 2 * t);
          const theta = goldenAngle * i;
          const sinPhi = Math.sin(phi);
          const cosPhi = Math.cos(phi);
          const baseX = Math.cos(theta) * sinPhi * sphereState.radius;
          const baseY = Math.sin(theta) * sinPhi * sphereState.radius;
          const baseZ = cosPhi * sphereState.radius;
          n.__sphere = { x: baseX, y: baseY, z: baseZ };
          n.vx = 0;
          n.vy = 0;
        });
      };

      const projectSphere = () => {
        if (!isSphereLayout) return;
        const width = graphCanvas.width / window.devicePixelRatio;
        const height = graphCanvas.height / window.devicePixelRatio;
        const centerX = width / 2;
        const centerY = height / 2;
        const cosX = Math.cos(sphereState.angleX);
        const sinX = Math.sin(sphereState.angleX);
        const cosY = Math.cos(sphereState.angleY);
        const sinY = Math.sin(sphereState.angleY);

        nodes.forEach((n) => {
          const base = n.__sphere || { x: 0, y: 0, z: 0 };
          const x1 = base.x * cosY - base.z * sinY;
          const z1 = base.x * sinY + base.z * cosY;
          const y1 = base.y * cosX - z1 * sinX;
          const z2 = base.y * sinX + z1 * cosX;
          const perspective = 0.6 + (z2 / Math.max(1, sphereState.radius * 2));
          const depthScale = clamp(perspective, 0.45, 1.25);
          n.x = centerX + x1 * depthScale;
          n.y = centerY + y1 * depthScale;
          n.__depth = depthScale;
        });
      };

      const spinSphere = () => {
        if (!isSphereLayout) return;
        if (sphereState.spinHandle) cancelAnimationFrame(sphereState.spinHandle);
        const step = () => {
          const now = performance.now();
          sphereState.velocityX += (sphereState.targetVX - sphereState.velocityX) * 0.12;
          sphereState.velocityY += (sphereState.targetVY - sphereState.velocityY) * 0.12;
          const wobbleX = sphereState.hovering ? Math.sin(now * 0.0012) * sphereState.wobbleAmp : 0;
          const wobbleY = sphereState.hovering ? Math.cos(now * 0.001) * sphereState.wobbleAmp : 0;
          sphereState.angleX += sphereState.velocityX + wobbleX;
          sphereState.angleY += sphereState.velocityY + wobbleY;
          draw();
          sphereState.spinHandle = requestAnimationFrame(step);
        };
        sphereState.spinHandle = requestAnimationFrame(step);
      };

      const centerOnNode = (node, withZoom, immediate, scaleOverride) => {
        if (!node) return;
        const width = graphCanvas.width / window.devicePixelRatio;
        const height = graphCanvas.height / window.devicePixelRatio;
        const targetScale = scaleOverride || (withZoom ? Math.min(options.maxScale, camera.scale * 1.15) : camera.scale);
        const targetX = width / 2 - node.x * targetScale;
        const targetY = height / 2 - node.y * targetScale;
        if (immediate) {
          camera.x = targetX;
          camera.y = targetY;
          camera.scale = targetScale;
          isAnimating = false;
          return;
        }
        animFrom = { x: camera.x, y: camera.y, scale: camera.scale };
        animTo = { x: targetX, y: targetY, scale: targetScale };
        animStart = performance.now();
        isAnimating = true;
      };

      const centerOnCurrent = () => {
        if (!options.centerOnCurrent) return;
        if (focusNode) return;
        const current = nodes.find((n) => isCurrentPath(n.path));
        focusNode = current || null;
        hoverNode = current || null;
        centerOnNode(current, false, true);
      };

      const fitToCanvas = () => {
        const width = graphCanvas.width / window.devicePixelRatio;
        const height = graphCanvas.height / window.devicePixelRatio;
        if (!nodes.length || width === 0 || height === 0) return;

        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        nodes.forEach((n) => {
          minX = Math.min(minX, n.x);
          maxX = Math.max(maxX, n.x);
          minY = Math.min(minY, n.y);
          maxY = Math.max(maxY, n.y);
        });

        const padding = Math.max(12, Math.min(width, height) * 0.04);
        const contentWidth = Math.max(1, maxX - minX);
        const contentHeight = Math.max(1, maxY - minY);
        const paddedWidth = contentWidth + padding * 2;
        const paddedHeight = contentHeight + padding * 2;

        const scaleX = width / paddedWidth;
        const scaleY = height / paddedHeight;
        const fitScale = Math.min(scaleX, scaleY);
        const targetScale = Math.max(options.minScale, Math.min(options.maxScale, fitScale));

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        camera.scale = targetScale;
        camera.x = width / 2 - centerX * targetScale;
        camera.y = height / 2 - centerY * targetScale;
      };

      const resize = () => {
        const rect = graphWrapper.getBoundingClientRect();
        const maxHeight = Math.round(window.innerHeight * safeHeightFactor);
        const w = Math.max(240, rect.width);
        const h = Math.max(240, rect.height || w);
        graphCanvas.width = w * window.devicePixelRatio;
        graphCanvas.height = h * window.devicePixelRatio;
        graphCanvas.style.width = w + "px";
        graphCanvas.style.height = h + "px";
        ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
        camera.scale = options.defaultScale;
        if (options.layout === "radial") {
          layoutRadial();
          fitToCanvas();
          centerOnCurrent();
          draw();
        } else if (isSphereLayout) {
          layoutSphere();
          projectSphere();
          centerOnCurrent();
          draw();
          spinSphere();
        } else {
          initLayout();
          tick(60);
          fitToCanvas();
          centerOnCurrent();
          draw();
        }
      };

      const toWorld = (x, y) => {
        return {
          x: (x - camera.x) / camera.scale,
          y: (y - camera.y) / camera.scale,
        };
      };

      const toScreen = (x, y) => {
        return {
          x: x * camera.scale + camera.x,
          y: y * camera.scale + camera.y,
        };
      };

      const hitTest = (x, y) => {
        const point = toWorld(x, y);
        const fallbackRadius = options.nodeRadius + 3;
        for (let i = nodes.length - 1; i >= 0; i -= 1) {
          const n = nodes[i];
          const dx = point.x - n.x;
          const dy = point.y - n.y;
          const halfW = (n.__chipWidth || fallbackRadius * 2) / 2;
          const halfH = (n.__chipHeight || fallbackRadius * 2) / 2;
          if (Math.abs(dx) <= halfW && Math.abs(dy) <= halfH) return n;
        }
        return null;
      };

      const getGroupKey = (node) => {
        if (!options.groupKey) return "default";
        return options.groupKey(node) || "default";
      };

      const computeGroupAnchors = () => {
        const width = graphCanvas.width / window.devicePixelRatio;
        const height = graphCanvas.height / window.devicePixelRatio;
        const groups = Array.from(new Set(nodes.map((n) => getGroupKey(n))));
        const anchors = new Map();
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) * 0.22;
        groups.forEach((group, index) => {
          const angle = (Math.PI * 2 * index) / Math.max(groups.length, 1);
          anchors.set(group, {
            x: centerX + Math.cos(angle) * radius,
            y: centerY + Math.sin(angle) * radius,
          });
        });
        return anchors;
      };

      const tick = (iterations = 1) => {
        const anchors = computeGroupAnchors();
        const k = Math.sqrt((graphCanvas.width * graphCanvas.height) / nodes.length) / 2;
        const repulsion = options.repulsion;
        const spring = options.spring;
        const damping = 0.85;
        const interGroupRepulsion = options.interGroupRepulsion || 0;
        const clusterPull = options.clusterPull || 0;
        const roundness = options.roundness || 0;
        const linkStrength = options.linkStrength || 1;
        const focusLinkDistanceFactor = options.focusLinkDistanceFactor || 1;
        const focusLinkStrength = options.focusLinkStrength || 1;
        const focusLinkRepulsionFactor = options.focusLinkRepulsionFactor || 1;
        const width = graphCanvas.width / window.devicePixelRatio;
        const height = graphCanvas.height / window.devicePixelRatio;
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) * 0.28;
        const sphereRadius = radius * (options.sphereRadiusFactor || 1.0);
        const sphereStrength = options.sphereStrength || 0.02;
        const focusRelated = focusNode ? new Set([focusNode.id]) : null;

        if (focusRelated) {
          links.forEach((l) => {
            if (l.source === focusNode.id) focusRelated.add(l.target);
            if (l.target === focusNode.id) focusRelated.add(l.source);
          });
        }

        for (let iter = 0; iter < iterations; iter += 1) {
          for (let i = 0; i < nodes.length; i += 1) {
            const n1 = nodes[i];
            for (let j = i + 1; j < nodes.length; j += 1) {
              const n2 = nodes[j];
              const dx = n1.x - n2.x;
              const dy = n1.y - n2.y;
              const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;
              const sameGroup = getGroupKey(n1) === getGroupKey(n2);
              let repulsionStrength = sameGroup ? repulsion : repulsion + interGroupRepulsion;
              if (focusRelated && ((n1.id === focusNode.id && focusRelated.has(n2.id))
                || (n2.id === focusNode.id && focusRelated.has(n1.id)))) {
                repulsionStrength *= focusLinkRepulsionFactor;
              }
              const force = repulsionStrength / (dist * dist);
              const fx = (dx / dist) * force;
              const fy = (dy / dist) * force;
              n1.vx += fx;
              n1.vy += fy;
              n2.vx -= fx;
              n2.vy -= fy;
            }
          }

          if (clusterPull > 0) {
            nodes.forEach((n) => {
              const anchor = anchors.get(getGroupKey(n));
              if (!anchor) return;
              const dx = anchor.x - n.x;
              const dy = anchor.y - n.y;
              n.vx += dx * clusterPull;
              n.vy += dy * clusterPull;
            });
          }

          links.forEach((l) => {
            const source = byId.get(l.source);
            const target = byId.get(l.target);
            if (!source || !target) return;
            const dx = target.x - source.x;
            const dy = target.y - source.y;
            const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;
            let desired = k * 0.35;
            let linkBoost = 1;
            if (focusNode && (source.id === focusNode.id || target.id === focusNode.id)) {
              desired *= focusLinkDistanceFactor;
              linkBoost = focusLinkStrength;
            }
            const over = Math.max(0, dist - desired);
            const force = ((dist - desired) * spring * linkStrength * linkBoost)
              + (over > 0 ? over * spring * 0.6 : 0);
            const fx = (dx / dist) * force;
            const fy = (dy / dist) * force;
            source.vx += fx;
            source.vy += fy;
            target.vx -= fx;
            target.vy -= fy;
          });

          if (roundness > 0) {
            nodes.forEach((n) => {
              const dx = n.x - centerX;
              const dy = n.y - centerY;
              const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;
              const pull = (radius - dist) * roundness;
              n.vx += (dx / dist) * pull;
              n.vy += (dy / dist) * pull;
            });
          }

          if (sphereStrength > 0) {
            nodes.forEach((n) => {
              const dx = n.x - centerX;
              const dy = n.y - centerY;
              const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;
              const pull = (sphereRadius - dist) * sphereStrength;
              n.vx += (dx / dist) * pull;
              n.vy += (dy / dist) * pull;
            });
          }

          nodes.forEach((n) => {
            n.vx *= damping;
            n.vy *= damping;
            n.x = n.x + n.vx;
            n.y = n.y + n.vy;
            const dx = n.x - centerX;
            const dy = n.y - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;
            const maxR = sphereRadius;
            if (dist > maxR) {
              const scale = maxR / dist;
              n.x = centerX + dx * scale;
              n.y = centerY + dy * scale;
              n.vx *= 0.6;
              n.vy *= 0.6;
            }
          });
        }
      };

      const getRelatedSet = (node) => {
        if (!node) return null;
        const related = new Set([node.id]);
      links.forEach((l) => {
        const source = l.source;
        const target = l.target;
        if (source === node.id) related.add(target);
        if (target === node.id) related.add(source);
      });
      return related;
    };

      const drawRoundedRect = (x, y, w, h, r) => {
        ctx.beginPath();
        if (ctx.roundRect) {
          ctx.roundRect(x, y, w, h, r);
          return;
        }
        const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + w - radius, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
        ctx.lineTo(x + w, y + h - radius);
        ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
        ctx.lineTo(x + radius, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
      };

      const boldFont = options.boldFont || `600 ${options.font}`;

      const drawLabel = (text, screenX, screenY, isActive, emphasize) => {
        const paddingX = 8;
        const paddingY = 5;
        const font = emphasize ? boldFont : options.font;
        ctx.font = font;
        const metrics = ctx.measureText(text);
        const ascent = metrics.actualBoundingBoxAscent || 10;
        const descent = metrics.actualBoundingBoxDescent || 2;
        const textHeight = ascent + descent;
        const boxWidth = metrics.width + paddingX * 2;
        const boxHeight = textHeight + paddingY * 2;
        const labelX = screenX + 10;
        const labelY = Math.max(8, screenY - boxHeight - 6);

        ctx.save();
        ctx.textBaseline = "top";
        ctx.globalAlpha = isActive ? 0.98 : 0.82;
        ctx.fillStyle = colours.labelBg;
        ctx.strokeStyle = colours.labelBorder;
        ctx.lineWidth = 1;
        drawRoundedRect(labelX, labelY, boxWidth, boxHeight, 8);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = colours.textMuted;
        ctx.fillText(text, labelX + paddingX, labelY + paddingY);
        ctx.restore();
      };

      const draw = () => {
        const width = graphCanvas.width / window.devicePixelRatio;
        const height = graphCanvas.height / window.devicePixelRatio;
        if (isSphereLayout) projectSphere();
        ctx.clearRect(0, 0, width, height);

        const activeNode = hoverNode || focusNode;
        const related = getRelatedSet(activeNode);

        ctx.save();
        ctx.translate(camera.x, camera.y);
        ctx.scale(camera.scale, camera.scale);

        if (links.length) {
          ctx.strokeStyle = colours.link;
          ctx.lineWidth = 1 / camera.scale;
          links.forEach((l) => {
            const source = byId.get(l.source);
            const target = byId.get(l.target);
            if (!source || !target) return;
            const isRelated = !related || (related.has(source.id) && related.has(target.id));
            ctx.globalAlpha = isRelated ? 0.9 : 0.15;
            ctx.beginPath();
            ctx.moveTo(source.x, source.y);
            ctx.lineTo(target.x, target.y);
            ctx.stroke();
          });
        }

        ctx.font = options.font;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const renderNodes = isSphereLayout
          ? [...nodes].sort((a, b) => (a.__depth || 0) - (b.__depth || 0))
          : nodes;

        renderNodes.forEach((n) => {
          const isRelated = !related || related.has(n.id);
          const isFocused = focusNode && focusNode.id === n.id;
          const palette = tintedPalette(options.colorForNode(n));
          const depthScale = isSphereLayout ? n.__depth || 1 : 1;
          const chipWidth = (n.__chipWidth || options.nodeRadiusFor(n) * 3) * depthScale;
          const chipHeight = (n.__chipHeight || options.nodeRadiusFor(n) * 2.2) * depthScale;
          const radius = (n.__chipRadius || chipHeight / 2 + 6) * depthScale;
          const label = n.__label || labelForNode(n);

          ctx.globalAlpha = isRelated ? Math.min(1, 0.6 + depthScale * 0.6) : 0.18;
          ctx.lineWidth = (1.6 / camera.scale) * clamp(depthScale, 0.7, 1.6);
          ctx.beginPath();
          drawRoundedRect(n.x - chipWidth / 2, n.y - chipHeight / 2, chipWidth, chipHeight, radius);
          ctx.fillStyle = palette.fill;
          ctx.strokeStyle = palette.stroke;
          ctx.fill();
          ctx.stroke();

          if (isFocused || (hoverNode && hoverNode.id === n.id)) {
            ctx.strokeStyle = colours.highlight;
            ctx.lineWidth = (isFocused ? 2.2 : 1.8) / camera.scale;
            ctx.stroke();
          }

          ctx.fillStyle = palette.text;
          ctx.shadowColor = isFocused ? colours.highlight : "transparent";
          ctx.shadowBlur = isFocused ? 10 / camera.scale : 0;
          ctx.fillText(label, n.x, n.y);
          ctx.shadowBlur = 0;
        });
        ctx.globalAlpha = 1;

        ctx.restore();

        if (related || !focusNode) {
          ctx.font = options.font;
          nodes.slice(0, options.labelLimit).forEach((n) => {
            if (activeNode) {
              if (!related || !related.has(n.id)) return;
            } else if (n.layout !== "page") {
              return;
            }
            const label = n.label || "";
            if (!label) return;
            const text = label.length > options.labelMax ? label.slice(0, options.labelMax - 3) + "..." : label;
            const screen = toScreen(n.x, n.y);
            drawLabel(text, screen.x, screen.y, !!activeNode, options.emphasizeNode?.(n));
          });
        }
      };

      const animateFrame = () => {
        if (!isAnimating) return;
        const now = performance.now();
        const t = Math.min(1, (now - animStart) / 320);
        const ease = t * (2 - t);
        if (animFrom && animTo) {
          camera.x = animFrom.x + (animTo.x - animFrom.x) * ease;
          camera.y = animFrom.y + (animTo.y - animFrom.y) * ease;
          camera.scale = animFrom.scale + (animTo.scale - animFrom.scale) * ease;
        }
        draw();
        if (t < 1) {
          requestAnimationFrame(animateFrame);
        } else {
          isAnimating = false;
        }
      };

      graphWrapper.addEventListener("mousedown", (event) => {
        isDragging = true;
        didDrag = false;
        lastDrag = { x: event.clientX, y: event.clientY };
        dragClickGuard = false;
      });

      graphWrapper.addEventListener("mousemove", (event) => {
        const rect = graphCanvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        if (isDragging && lastDrag) {
          const dx = event.clientX - lastDrag.x;
          const dy = event.clientY - lastDrag.y;
          camera.x += dx;
          camera.y += dy;
          lastDrag = { x: event.clientX, y: event.clientY };
          didDrag = true;
          dragClickGuard = true;
          draw();
          return;
        }
        const hit = hitTest(x, y);
        if (hit !== hoverNode) {
          hoverNode = hit;
          draw();
        }
        if (isSphereLayout && !isDragging) {
          const width = graphCanvas.width / window.devicePixelRatio;
          const height = graphCanvas.height / window.devicePixelRatio;
          const normX = x / Math.max(1, width);
          const normY = y / Math.max(1, height);
          const targetScale = sphereState.hovering ? 0.003 : 0.009;
          sphereState.targetVY = clamp((normX - 0.5) * targetScale, -targetScale, targetScale);
          sphereState.targetVX = clamp(-(normY - 0.5) * targetScale, -targetScale, targetScale);
        }
      });

      graphWrapper.addEventListener("mouseup", () => {
        isDragging = false;
        lastDrag = null;
        if (didDrag) {
          const target = focusNode || nodes.find((n) => isCurrentPath(n.path));
          if (target) {
            const targetScale = focusNode ? camera.scale : options.defaultScale;
            centerOnNode(target, false, false, targetScale);
            requestAnimationFrame(animateFrame);
          }
        }
        dragClickGuard = didDrag;
        didDrag = false;
      });

      graphWrapper.addEventListener("mouseleave", () => {
        isDragging = false;
        lastDrag = null;
        hoverNode = null;
        didDrag = false;
        dragClickGuard = false;
        if (isSphereLayout) {
          sphereState.hovering = false;
          sphereState.targetVX = 0.0009;
          sphereState.targetVY = -0.00078;
        }
        draw();
      });

      graphWrapper.addEventListener("mouseenter", () => {
        if (isSphereLayout) {
          sphereState.hovering = true;
          sphereState.targetVX = 0.00012;
          sphereState.targetVY = -0.0001;
        }
      });

      graphWrapper.addEventListener("click", (event) => {
        const rect = graphCanvas.getBoundingClientRect();
        const skipClick = dragClickGuard;
        dragClickGuard = false;
        if (skipClick) return;
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const hit = hitTest(x, y);
        if (hit) {
          if (!didDrag && hit.path) {
            window.location.href = hit.path;
            return;
          }
          focusNode = hit;
          centerOnNode(hit, true, false);
          requestAnimationFrame(animateFrame);
        } else {
          const current = nodes.find((n) => isCurrentPath(n.path));
          focusNode = current || null;
          hoverNode = current || null;
          if (current) {
            centerOnNode(current, false, false, camera.scale);
            requestAnimationFrame(animateFrame);
          } else {
            draw();
          }
        }
      });

      graphWrapper.addEventListener("wheel", (event) => {
        if (!options.enableZoom) return;
        event.preventDefault();
        const rect = graphCanvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const worldBefore = toWorld(x, y);
        const factor = event.deltaY < 0 ? 1.08 : 0.92;
        camera.scale = Math.min(options.maxScale, Math.max(options.minScale, camera.scale * factor));
        const worldAfter = toWorld(x, y);
        camera.x += (worldAfter.x - worldBefore.x) * camera.scale;
        camera.y += (worldAfter.y - worldBefore.y) * camera.scale;
        if (focusNode) {
          centerOnNode(focusNode, false, false);
          requestAnimationFrame(animateFrame);
        } else {
          draw();
        }
      }, { passive: false });

      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => resize());
        ro.observe(graphWrapper);
      } else {
        window.addEventListener("resize", resize);
      }
      resize();
    };

    const mainGroupKey = (node) => {
      const path = (node.path || "").toLowerCase();
      if (path.startsWith("/games/")) return "games";
      if (path.startsWith("/notes/rockhounding/")) return "rockhounding";
      if (path.startsWith("/notes/random/")) return "random";
      if (path.startsWith("/blog/")) {
        const date = (node.date || "").toString();
        const match = date.match(/^(\\d{4})-(\\d{2})/);
        return match ? `blog-${match[1]}-${match[2]}` : "blog";
      }
      if (path.startsWith("/notes/")) {
        const parts = path.split("/").filter(Boolean);
        const folder = parts.slice(1, parts.length > 2 ? parts.length - 1 : parts.length).join("/");
        return folder || "notes";
      }
      if (node.layout === "page") return "pages";
      return node.category || "notes";
    };

    buildGraph(wrapper, canvas, data, {
      nodeRadius: 5,
      repulsion: 180,
      spring: 0.12,
      labelLimit: 140,
      labelMax: 30,
      font: "11px ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif",
      emphasizeNode: isCategoryNode,
      centerOnCurrent: true,
      defaultScale: 1.18,
      minScale: 1.0,
      maxScale: 1.8,
      enablePan: false,
      enableZoom: true,
      roundness: 0,
      sphereRadiusFactor: 0.54,
      sphereStrength: 0,
      interGroupRepulsion: 0,
      clusterPull: 0,
      groupKey: null,
      linkStrength: 1.8,
      focusLinkDistanceFactor: 0.55,
      focusLinkStrength: 1.8,
      focusLinkRepulsionFactor: 0.4,
      layout: "sphere",
      colorForNode,
      chipPaddingX: 10,
      chipPaddingY: 5,
      nodeRadiusFor: (n) => {
        const base = n.layout === "page" ? 5.5 : 3.8;
        const boost = Math.sqrt(n.degree || 0) * 1.0;
        return base + boost;
      },
    });

    buildGraph(tagWrapper, tagCanvas, tagGraphData, {
      nodeRadius: 7,
      repulsion: 200,
      spring: 0.02,
      labelLimit: 180,
      labelMax: 24,
      font: "600 11px/1.25 ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif",
      centerOnCurrent: false,
      defaultScale: 1.16,
      minScale: 1.0,
      maxScale: 1.8,
      enablePan: false,
      enableZoom: true,
      roundness: 0,
      interGroupRepulsion: 0,
      clusterPull: 0,
      groupKey: (n) => n.type || "tag",
      layout: "sphere",
      sphereRadiusFactor: 0.58,
      colorForNode: (n) => (n.type === "tag" ? colours.notes : colours.page),
      chipPaddingX: 10,
      chipPaddingY: 5,
      nodeRadiusFor: (n) => (n.type === "tag" ? Math.min(10, 4.5 + (n.count || 1) * 0.28) : 3.5),
    });
  })();
</script>
